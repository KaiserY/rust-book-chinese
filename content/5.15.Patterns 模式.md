# æ¨¡å¼
æ¨¡å¼åœ¨Rustä¸­ååˆ†å¸¸è§ã€‚æˆ‘ä»¬åœ¨[å˜é‡ç»‘å®š](http://doc.rust-lang.org/nightly/book/variable-bindings.html)ï¼Œ[åŒ¹é…è¯­å¥](http://doc.rust-lang.org/nightly/book/match.html)å’Œå…¶å®ƒä¸€äº›åœ°æ–¹ä½¿ç”¨å®ƒä»¬ã€‚è®©æˆ‘ä»¬å¼€å§‹ä¸€ä¸ªå¿«é€Ÿçš„å…³äºæ¨¡å¼å¯ä»¥å¹²ä»€ä¹ˆçš„æ•™ç¨‹ï¼

å¿«é€Ÿå›é¡¾ï¼šä½ å¯ä»¥ç›´æ¥åŒ¹é…å¸¸é‡ï¼Œå¹¶ä¸”`_`ä½œä¸ºâ€œä»»ä½•â€ç±»å‹ï¼š

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

è¿™ä¼šæ‰“å°å‡º`one`ã€‚

## å¤šé‡æ¨¡å¼ï¼ˆMultiple patternsï¼‰
ä½ å¯ä»¥ä½¿ç”¨`|`åŒ¹é…å¤šä¸ªæ¨¡å¼ï¼š

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

è¿™ä¼šè¾“å‡º`one or two`ã€‚

## èŒƒå›´ï¼ˆRangesï¼‰
ä½ å¯ä»¥ç”¨`...`åŒ¹é…ä¸€ä¸ªèŒƒå›´çš„å€¼ï¼š

```rust
let x = 1;

match x {
    1 ... 5 => println!("one through five"),
    _ => println!("anything"),
}
```

è¿™ä¼šè¾“å‡º`one through five`ã€‚

èŒƒå›´ç»å¸¸ç”¨åœ¨æ•´æ•°å’Œ`char`ä¸Šã€‚

```rust
let x = 'ğŸ’…';

match x {
    'a' ... 'j' => println!("early letter"),
    'k' ... 'z' => println!("late letter"),
    _ => println!("something else"),
}
```

è¿™ä¼šè¾“å‡º`something else`ã€‚

## ç»‘å®š
ä½ å¯ä»¥ä½¿ç”¨`@`æŠŠå€¼ç»‘å®šåˆ°åå­—ä¸Šï¼š

```rust
let x = 1;

match x {
    e @ 1 ... 5 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

è¿™ä¼šè¾“å‡º`got a range element 1`ã€‚åœ¨ä½ æƒ³å¯¹ä¸€ä¸ªå¤æ‚æ•°æ®ç»“æ„è¿›è¡Œéƒ¨åˆ†åŒ¹é…çš„æ—¶å€™ï¼Œè¿™ä¸ªç‰¹æ€§ååˆ†æœ‰ç”¨ï¼š

```rust
#[derive(Debug)]
struct Person {
    name: Option<String>,
}

let name = "Steve".to_string();
let mut x: Option<Person> = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) => println!("{:?}", a),
    _ => {}
}
```

è¿™ä¼šè¾“å‡º `Some("Steve")`ï¼Œå› ä¸ºæˆ‘ä»¬æŠŠPersoné‡Œé¢çš„`name`ç»‘å®šåˆ°`a`ã€‚

å¦‚æœä½ åœ¨ä½¿ç”¨`|`çš„åŒæ—¶ä¹Ÿä½¿ç”¨äº†`@`ï¼Œä½ éœ€è¦ç¡®ä¿åå­—åœ¨æ¯ä¸ªæ¨¡å¼çš„æ¯ä¸€éƒ¨åˆ†éƒ½ç»‘å®šåå­—ï¼š

```rust
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

## å¿½ç•¥å˜é‡ï¼ˆIgnoring variantsï¼‰
å¦‚æœä½ åŒ¹é…ä¸€ä¸ªå¸¦æœ‰å˜é‡çš„æšä¸¾ï¼Œä½ å¯ä»¥ç”¨`..`æ¥å¿½ç•¥å˜é‡çš„å€¼å’Œç±»å‹ï¼š

```rust
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(..) => println!("Got an int!"),
    OptionalInt::Missing => println!("No such luck."),
}
```

è¿™ä¼šè¾“å‡º`Got an int!`ã€‚

## å®ˆå«ï¼ˆGuardsï¼‰
ä½ å¯ä»¥ç”¨`if`æ¥å¼•å…¥*åŒ¹é…å®ˆå«*ï¼ˆ*match guards*ï¼‰ï¼š

```rust
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i > 5 => println!("Got an int bigger than five!"),
    OptionalInt::Value(..) => println!("Got an int!"),
    OptionalInt::Missing => println!("No such luck."),
}
```

è¿™ä¼šè¾“å‡º`Got an int!`ã€‚

## `ref`å’Œ`ref mut`
å¦‚æœä½ æƒ³è¦ä¸€ä¸ªå¼•ç”¨ï¼Œä½¿ç”¨`ref`å…³é”®å­—ï¼š

```rust
let x = 5;

match x {
    ref r => println!("Got a reference to {}", r),
}
```

è¿™ä¼šè¾“å‡º`Got a reference to 5`ã€‚

è¿™é‡Œï¼Œ`match`ä¸­çš„`r`æ˜¯`&i32`ç±»å‹çš„ã€‚æ¢å¥è¯è¯´ï¼Œ`ref`å…³é”®å­—åˆ›å»ºäº†ä¸€ä¸ªåœ¨æ¨¡å¼ä¸­ä½¿ç”¨çš„å¼•ç”¨ã€‚å¦‚æœä½ éœ€è¦ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œ`ref mut`åŒæ ·å¯ä»¥åšåˆ°ï¼š

```rust
let mut x = 5;

match x {
    ref mut mr => println!("Got a mutable reference to {}", mr),
}
```

## è§£æ„ï¼ˆDestructuringï¼‰
å¦‚æœä½ æœ‰ä¸€ä¸ªå¤åˆæ•°æ®ç±»å‹ï¼Œä¾‹å¦‚ä¸€ä¸ª[ç»“æ„ä½“](http://doc.rust-lang.org/stable/book/structs.html)ï¼Œä½ å¯ä»¥åœ¨æ¨¡å¼ä¸­è§£æ„å®ƒï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x, y: y } => println!("({},{})", x, y),
}
```

å¦‚æœä½ åªå…³å¿ƒéƒ¨åˆ†å€¼ï¼Œæˆ‘ä»¬ä¸éœ€è¦ç»™å®ƒä»¬éƒ½å‘½åï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x, .. } => println!("x is {}", x),
}
```

è¿™ä¼šè¾“å‡º`x is 0`ã€‚

ä½ å¯ä»¥å¯¹ä»»ä½•æˆå‘˜è¿›è¡Œè¿™æ ·çš„åŒ¹é…ï¼Œä¸ä»…ä»…æ˜¯ç¬¬ä¸€ä¸ªï¼š

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { y: y, .. } => println!("y is {}", y),
}
```

è¿™ä¼šè¾“å‡º`y is 0`ã€‚

è¿™ç§â€œè§£æ„â€è¡Œä¸ºå¯ä»¥ç”¨åœ¨ä»»ä½•å¤åˆæ•°æ®ç±»å‹ä¸Šï¼Œä¾‹å¦‚[å…ƒç»„](http://doc.rust-lang.org/nightly/book/primitive-types.html#tuples)å’Œ[æšä¸¾](http://doc.rust-lang.org/nightly/book/enums.html)

## æ··åˆä¸åŒ¹é…ï¼ˆMix and Matchï¼‰
(å£å“¨)ï¼æ ¹æ®ä½ çš„éœ€æ±‚ï¼Œä½ å¯ä»¥å¯¹ä¸Šé¢çš„å¤šç§åŒ¹é…æ–¹æ³•è¿›è¡Œç»„åˆï¼š

```rust
match x {
    Foo { x: Some(ref name), y: None } => ...
}
```

æ¨¡å¼ååˆ†å¼ºå¤§ã€‚å¥½å¥½ä½¿ç”¨å®ƒä»¬ã€‚
