#哲学家就餐问题

> 原文 [dining-philosophers.md](https://github.com/rust-lang/rust/blob/fcf8dedb99fa674a152b5625dd81938c4d8ff67b/src/doc/trpl/dining-philosophers.md)
> commit: fcf8dedb99fa674a152b5625dd81938c4d8ff67b

在第二个项目里，我们来了解一个经典的并发编程问题，“哲学家就餐问题”。这个问题在最早由迪科斯彻（*E. Dijkstra*）在 1965 年提出（译注：英文维基写的是 1965，然而中文维基上是 1971），不过这里我们引用托尼·霍尔（*C. A. R. Hoare*）于 [Communicating Sequential Processes][paper] 中的改写版。

[paper]: http://www.usingcsp.com/cspbook.pdf

>古时候，一位非常富有的慈善家出钱资助一所学院，让学院为五位杰出的哲学家提供食宿。每个哲学家都有一个房间，他可以在里面专心思考；但是餐厅是公共的，里面摆了一张圆桌、五把椅子，每把椅子上都标有一位哲学家的名字。哲学家们以逆时针次序围坐在桌旁。在每位哲学家的左侧放着一把金叉，桌子正中间摆着一个大碗，里面盛着细条通心面，而且随时有人添加着。
>
>哲学家本来就是要把他的主要时间用于思考的；但如果觉得饿了，他就去餐厅，坐在他的椅子上，拿起放在左边的叉子，吃一顿细条通心面。可是事情并没有这么简单，要把缠结的通心面送到嘴里，必须用第二把叉子。所以这位哲学家非得把他右边的叉子也拿起来不可。一旦吃完了，他就放下两把叉子，站起来回到他房间里继续思考去。当然，一把叉子一次只能由一个人用。如果又有一位哲学家要用这把叉子，他只能等头一位哲学家用完了再说。
>
> *《通信顺序进程》 周巢尘译，北京大学出版社，1990.01*

这个经典的问题揭示了不同元素间的并发问题。如果简单地实现这个程序而不加特殊处理，可能会导致死锁。如果一位哲学家希望吃面，他必须这样做：

1. 拿起左边的叉子。
2. 叉好面条后，拿起右边的叉子。
3. 吃下面条。
4. 放下叉子。

现在请打开你的脑洞，想像下面的情景：

1. 孔子饿了，他拿起左手边的叉子。
2. 孟子饿了，他拿起左手边的叉子。
3. 老子饿了，他拿起左手边的叉子。
4. 庄子饿了，他拿起左手边的叉子。
5. 韩非子饿了，他拿起左手边的叉子。
6. 。。。没叉子了，但也没人吃到东西？

解决这个问题有多种办法。我们将在本节用自己的办法慢慢解决这个问题。现在先从哲学家开始建模：

```rust
struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}

fn main() {
    let p1 = Philosopher::new("孔子");
    let p2 = Philosopher::new("孟子");
    let p3 = Philosopher::new("老子");
    let p4 = Philosopher::new("庄子");
    let p5 = Philosopher::new("韩非子");
}
```

第一段代码创建了一个 [`struct`（结构）][struct] 来表示一个哲学家，到目前为止，结构只需要一个字段来表示哲学家的名字。而 [`String`（字符串）][string] 类型用来表示名字，并非 `&str`。通常来说，操作一个拥有自己数据的类型，比起操作一个拥有引用的类型，要简单得多。

[struct]: 5.11.Structs%20结构体.html
[string]: 5.17.Strings%20字符串.html

第二段代码：

```rust
# struct Philosopher {
#     name: String,
# }
impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}
```

`impl` 块内定义了 `Philosopher` 结构的内容，此处有一个名叫 `new` 的“关联函数”。来看看它的第一行：

```rust
# struct Philosopher {
#     name: String,
# }
# impl Philosopher {
fn new(name: &str) -> Philosopher {
#         Philosopher {
#             name: name.to_string(),
#         }
#     }
# }
```

参数 `name` 的类型为  `&str`，这是另一个字符串的引用。`new` 函数返回 `Philsopher` 结构的一个新实例。

```rust
# struct Philosopher {
#     name: String,
# }
# impl Philosopher {
#    fn new(name: &str) -> Philosopher {
Philosopher {
    name: name.to_string(),
}
#     }
# }
```

函数的主体部分创建一个新的 `Philsopher`，将它的 `name` 字段设置为 `name` 参数。不仅仅是 `name`  参数本身，而是 `name.to_string()`。这将会创建 `&str` 对象的一个副本，一个 `String` 对象。`name` 字段即是 `String` 对象。

为什么不用 `String` 类型作为参数呢？假如参数为 `String` 类型，但是调用方只有 `&str` 类型的值，那么每次调用方都必须自己调用 `.to_string()` 函数，加大了代码量。

这种灵活性的缺点在于，必须*每次*都复制（克隆）一个新的字符串。对于这种小程序来说，这并不是很重要，因为程序中使用的都是一些短小的字符串。

这里好像只新建了 `Philsopher`，没有具体的操作，怎么就是一个函数了呢？真相是，Rust 是 “基于表达式”的编程语言，其中的几乎所有东西都是返回“值”的表达式。这个规律对于函数也成立，函数内的最后一个表达式被自动作为了返回值。`new` 函数的最后一个表达式是一个新的 `Philsopher` 对象，所以它就是返回值。

`new()` 这个名字在 Rust 语言里面一点也不特殊，换言之，它不是一个关键字。然而，创建结构的新实例时，按照习惯，都会使用 `new` 这个名字。要问为什么要使用 `new()`的话，让我们再看看 `main()` 函数：

```rust
# struct Philosopher {
#     name: String,
# }
#
# impl Philosopher {
#     fn new(name: &str) -> Philosopher {
#         Philosopher {
#             name: name.to_string(),
#         }
#     }
# }
#
fn main() {
    let p1 = Philosopher::new("孔子");
    let p2 = Philosopher::new("孟子");
    let p3 = Philosopher::new("老子");
    let p4 = Philosopher::new("庄子");
    let p5 = Philosopher::new("韩非子");
```

这段代码创建了 5 个表示哲学家的变量绑定。不一定要选择春秋时期的思想家；你也可以选择你喜欢的其他学者。假设没有 `new()` 方法，那么代码就会变成这样：

```rust
# struct Philosopher {
#     name: String,
# }
fn main() {
    let p1 = Philosopher { name: "孔子".to_string() };
    let p2 = Philosopher { name: "孟子".to_string() };
    let p3 = Philosopher { name: "老子".to_string() };
    let p4 = Philosopher { name: "庄子".to_string() };
    let p5 = Philosopher { name: "韩非子".to_string() };
}
```

语法噪音确实要严重一些。`new` 函数还有其他的好处，但即使是在这个简单的小地方，也确实更易于使用。

现在，大家已经具备了一些基础知识。解决这个编程问题的方法很多，这里我们先从程序末尾开始，让哲学家能够吃到面条。于是，我们首先创建 `eat()` 方法，再遍历哲学家列表，调用他们的 `eat()` 方法：

```rust
struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }

    fn eat(&self) {
        println!("{} 吃完了。", self.name);
    }
}

fn main() {
    let philosophers = vec![
        Philosopher::new("孔子"),
        Philosopher::new("孟子"),
        Philosopher::new("老子"),
        Philosopher::new("庄子"),
        Philosopher::new("韩非子"),
    ];

    for p in &philosophers {
        p.eat();
    }
}
```

先来看看 `main()` 函数。哲学家们并非被存储在五个单独的变量绑定中，而是在一个 `Vec<T>` 中。`Vec<T>` 又被称作“Vector”，一个变长数组。接着，[`for`][for] 循环遍历这个 vector，按顺序获取每个 `Philsopher` 的引用。

[for]: 5.6.Loops 循环.md

循环的主体部分里，我们调用了 `p.eat()`，定义如下：

```rust,ignore
fn eat(&self) {
    println!("{}吃完了。", self.name);
}
```

在 Rust 中，所有方法都显式接受一个 `self` 参数。`eat()` 接受了 `self` 参数，所以它是一个方法；而 `new()` 不接受 `self`，所以它只是一个关联函数。

```text
孔子吃完了。
孟子吃完了。
老子吃完了。
庄子吃完了。
韩非子吃完了。
```

屏幕上的输出表示他们都吃完了。然而远远还没完——他们其实根本没有吃东西！

现在，我们需要模拟出真正吃东西的过程。再来完善一下代码：

```rust
use std::thread;

struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }

    fn eat(&self) {
        println!("△ {}开饭了。", self.name);

        thread::sleep_ms(1000);

        println!("√ {}吃完了。", self.name);
    }
}

fn main() {
    let philosophers = vec![
        Philosopher::new("孔子"),
        Philosopher::new("孟子"),
        Philosopher::new("老子"),
        Philosopher::new("庄子"),
        Philosopher::new("韩非子"),
    ];

    for p in &philosophers {
        p.eat();
    }
}
```

这次又做了一点小小的改动。让我们一处一处来看。

```rust,ignore
use std::thread;
```

`use` 将名称引入作用域。马上会用到来自标准库的 `thread` 模块，所以需要使用 `use` 来引入它。

```rust,ignore
    fn eat(&self) {
        println!("△ {}开饭了。", self.name);

        thread::sleep_ms(1000);

        println!("√ {}吃完了。", self.name);
    }
```

这段代码会在屏幕上打印两个信息，之间用 `sleep_ms()` 来隔开，模拟哲学家们吃面的时间。

运行这段程序，即可见识众学者依次吃面的宏大场景：

```text
△ 孔子开饭了。
√ 孔子吃完了。
△ 孟子开饭了。
√ 孟子吃完了。
△ 老子开饭了。
√ 老子吃完了。
△ 庄子开饭了。
√ 庄子吃完了。
△ 韩非子开饭了。
√ 韩非子吃完了。
```

棒极了！一切如我们所愿，程序正常工作。下一步，深入问题的关键——让程序并行化。

增加一些新的代码，以便让哲学家们同时就餐：

```rust
use std::thread;

struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }

    fn eat(&self) {
        println!("△ {}开饭了。", self.name);

        thread::sleep_ms(1000);

        println!("√ {}吃完了。", self.name);
    }
}

fn main() {
    let philosophers = vec![
        Philosopher::new("孔子"),
        Philosopher::new("孟子"),
        Philosopher::new("老子"),
        Philosopher::new("庄子"),
        Philosopher::new("韩非子"),
    ];

    let handles: Vec<_> = philosophers.into_iter().map(|p| {
        thread::spawn(move || {
            p.eat();
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }
}
```

这一次，我们修改了 `main()` 内的循环，还增加了一个循环。下面是第一处改动：

```rust,ignore
let handles: Vec<_> = philosophers.into_iter().map(|p| {
    thread::spawn(move || {
        p.eat();
    })
}).collect();
```
这 5 行代码，每一行都极为关键。让我们逐步来分析：

```rust,ignore
let handles: Vec<_> =
```

这一行创建了一个名为 `handles` 的绑定。下面的代码里即将创建一些新线程，而它们的句柄（*handle*）将会被存储到此绑定中（它由此而得名）——线程的句柄用来操纵线程本身。此时必须显式指定绑定的类型，具体原因将稍后提到。最后，`_` 是一个类型占位符，它仿佛在对编译器说：“Rust 君，`handles` 是一个 vector，下面就由你自己来判断具体类型吧。”

```rust,ignore
philosophers.into_iter().map(|p| {
```

紧接着，对哲学家列表调用了 `into_iter()` 方法，来创建它的迭代器，并取得每位哲学家的所有权。这样就将在稍后将所有权传递给子线程——这是必需的一步。取得迭代器之后，调用了迭代器的 `map` 方法：`map` 方法接受一个闭包（*closure*）作为参数，并且将按顺序对所有元素调用此闭包。

```rust,ignore
    thread::spawn(move || {
        p.eat();
    })
```

这里是并发操作的地方。`thread::spawn` 函数接受一个闭包作为参数，然后在新线程中执行这个闭包。闭包的 `move` 标记表示该闭包将取得所有它所捕捉对象（这里是 `map` 函数的 `p` 变量——哲学家们）的所有权。

线程内调用了 `p` 对象的 `eat()` 方法。请注意，`thread::spawn` 的结尾没有分号，所以它是一个表达式：该处要求一个表达式，并非一个语句。欲知更多详情，请见 [表达式和语句][es] 一节。

[es]: 5.2.Functions 函数.md#expressions-vs.-statements

```rust,ignore
}).collect();
```

最后，`collect()` 方法将`map` 的返回值收集于集合中。该集合的具体类型将依据上下文而定：上文创建 `handles` 绑定时其类型已被显式指定为 `Vec<T>`。返回的集合内的元素即为 `thread::spawn` 的返回值（新建线程的句柄）。

Duang！

```rust,ignore
for h in handles {
    h.join().unwrap();
}
```

`main()` 函数的结尾，我们遍历了这些句柄，并调用了句柄的 `join()` 方法。这使得主程序执行中断，直到句柄对应线程退出，从而保证在主程序退出之前所有子线程先退出。

运行这个程序，你就会发现哲学家们正在有序地吃着食物。啊，多么美妙的多线程！

```text
△ 孔子开饭了。
△ 孟子开饭了。
△ 老子开饭了。
△ 庄子开饭了。
△ 韩非子开饭了。
√ 孔子吃完了。
√ 孟子吃完了。
√ 老子吃完了。
√ 庄子吃完了。
√ 韩非子吃完了。
```
（*译注：在 Rust Playground 或者其他运行环境中，输出的顺序可能会有差别，因为这是并行程序。具体可参见 https://play.rust-lang.org/?gist=ca2a739692a5568b44e7&version=stable*）

最后一件事，是为叉子建模。

为此需要创建一个新的结构：

```rust
use std::sync::Mutex;

struct Table {
    forks: Vec<Mutex<()>>,
}
```

`Table` 结构内有一个以互斥体（*`Mutex`*）为元素的 Vector。互斥体能够控制并发的操作：单个互斥体每刻只有一个线程能够访问；同样，单个叉子每刻只能供一个哲学家使用。实际不会使用互斥体内的值，所以互斥体内只有一个空元组 `()` ，表示仅仅持有它。

现在，修改此程序，以让其使用 `Table`：

```rust
use std::thread;
use std::sync::{Mutex, Arc};

struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}

impl Philosopher {
    fn new(name: &str, left: usize, right: usize) -> Philosopher {
        Philosopher {
            name: name.to_string(),
            left: left,
            right: right,
        }
    }

    fn eat(&self, table: &Table) {
        let _left = table.forks[self.left].lock().unwrap();
        let _right = table.forks[self.right].lock().unwrap();

        println!("△ {}开饭了。", self.name);

        thread::sleep_ms(1000);

        println!("√ {}吃完了。", self.name);
    }
}

struct Table {
    forks: Vec<Mutex<()>>,
}

fn main() {
    let table = Arc::new(Table { forks: vec![
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
    ]});

    let philosophers = vec![
        Philosopher::new("孔子", 0, 1),
        Philosopher::new("孟子", 1, 2),
        Philosopher::new("老子", 2, 3),
        Philosopher::new("庄子", 3, 4),
        Philosopher::new("韩非子", 0, 4),
    ];

    let handles: Vec<_> = philosophers.into_iter().map(|p| {
        let table = table.clone();

        thread::spawn(move || {
            p.eat(&table);
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }
}
```

改了相当多的地方，不过现在程序可以正常工作了。下面让我们来看看，这次新增了什么东西。

```rust,ignore
use std::sync::{Mutex, Arc};
```

程序开头增加了一个 using `Arc<T>` ，`Arc<T>` 也属于  `std::sync`。过一会使用 `Arc<T>` 的时候，再来了解它。

```rust,ignore
struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}
```

`Philsopher` 结构中多了 `usize` 类型的 `left` 与 `right` 字段。`usize` 是 vetcor 的索引的类型。这两个字段即为 `Table` 结构中 `forks` 的索引，表示哲学家左手和右手旁叉子的序号。

```rust,ignore
fn new(name: &str, left: usize, right: usize) -> Philosopher {
    Philosopher {
        name: name.to_string(),
        left: left,
        right: right,
    }
}
```

初始化 `left` 与 `right` 字段的工作，放在 `new()` 函数中来完成。

```rust,ignore
fn eat(&self, table: &Table) {
    let _left = table.forks[self.left].lock().unwrap();
    let _right = table.forks[self.right].lock().unwrap();
    
    println!("△ {}开饭了。", self.name);
    
    thread::sleep_ms(1000);
    
    println!("√ {}吃完了。", self.name);
}
```

新增的两行代码在 `table` 参数的 `forks` 字段中得到叉子列表，然后使用 `self.left` 以及 `self.right` 索引来找到自己的叉子（的互斥体），最后调用 `lock()` 方法来锁上互斥体。假如互斥体已经被锁上（叉子正在被使用），当前线程就会阻塞，直到叉子再次可用。

对 `lock()` 的调用有可能会失败，假设确实失败了，那么我们希望程序立即崩溃。在这里，假设互斥体对象[“被污染”（*poisoned*）][poison]（在线程持有锁的时候线程恐慌），那么调用就会失败。这应该不会发生，所以只需 `unwrap()` 就行。

[poison]: http://doc.rust-lang.org/nightly/std/sync/struct.Mutex.html#poisoning

还有一件怪事，为什么结果的名字带有下划线，叫 `_left` 与 `_right` 呢？嗯，好问题。现在没有_使用_这些值，而仅仅是_获得_它们（为了保持锁不被释放）。这样一来 Rust 编译器就会给一个警告，表明这些值从未被使用。而下划线就是告诉 Rust 编译器，这就是我们要做的事，别给这个警告。最后，当 `_left` 与 `_right` 退出其作用域时，锁就会自动被释放。

```rust,ignore
    let table = Arc::new(Table { forks: vec![
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
    ]});
```

接下来，在 `main()` 函数中，创建了新的 `Table` 对象，并将其包括在了 `Arc<T>` 中。“arc” 的意思是““原子引用计数”（*atomic reference count*），因为需要在多个线程中共享 `Table`。共享它时，计数会增长，而在线程结束时计数会下降。

```rust,ignore
let philosophers = vec![
        Philosopher::new("孔子", 0, 1),
        Philosopher::new("孟子", 1, 2),
        Philosopher::new("老子", 2, 3),
        Philosopher::new("庄子", 3, 4),
        Philosopher::new("韩非子", 0, 4),
];
```

`left` 与 `right` 的值被传递给了 `Philsopher` 的构造函数。有一个重要的细节需要我们留意：这些数字从头到尾都是连续的，但是韩非子除外。韩非子本来应该拿起第 `4, 0` 把叉子，但是现在是 `0, 4`。为了避免死锁，韩非子被弄成了左撇子。这是该问题的一个解法，在我看来是最简单的解法。

```rust,ignore
let handles: Vec<_> = philosophers.into_iter().map(|p| {
    let table = table.clone();

    thread::spawn(move || {
        p.eat(&table);
    })
}).collect();
```

最后，在 `map()`/`collect()` 循环中调用了 `table.clone()`。`Arc<T>` 的 `clone()` 方法会克隆当前值，并且递增引用计数；当变量离开作用域时，将递减引用计数。引用计数让我们知道有多少 `table` 在线程中存在，从而正确释放它们。假设没有一个准确的数目，就没法准确释放这些资源。

这里还建立了新的 `table` 绑定，它覆盖了旧的 `table`。在不想弄出两个名字的时候可以用这一招。

不错，现在程序正常工作了，并且同一时刻只有两个哲学家在吃东西。
程序会产生像这样的输出：

```text
△ 孔子开饭了。
△ 老子开饭了。
√ 孔子吃完了。
√ 老子吃完了。
△ 韩非子开饭了。
△ 孟子开饭了。
√ 韩非子吃完了。
△ 庄子开饭了。
√ 孟子吃完了。
√ 庄子吃完了。
```

恭喜！你成功使用 Rust 实现了一个经典的并发问题。